import os, sys
lib_path = os.path.abspath(os.path.join('..','_Libraries'))
sys.path.append(lib_path)

from rlabs_libutils import DataStruct, is_outlier, rgb2hex, movingaverage, find_nearest_above
import glob 								# to list the files in directory
import numpy as np 							# to read data
import matplotlib.pyplot as plt 			# to plot
import time 								# to name figures
import shutil 								# to delete folders

from collections import OrderedDict			# for plotTC

from Tkinter import Tk 						# for open file GUI
from tkFileDialog import askopenfilenames 	# for open file GUI
from tkSimpleDialog import askstring 		# if name of html exists,
from tkMessageBox import askquestion 		# ask new name

from bokeh.resources import CDN
from bokeh.embed import components, file_html
from bokeh import mpl
from bokeh.plotting import figure, output_file, show, VBox, reset_output, ColumnDataSource
from bokeh.models import HoverTool

def main(datafileslist='', DIR_OUT='', fWeb_HEADER='html_template.html', DATE_TIME_format="%Y-%m-%d_%H.%M", input_extension='*.txt',
	A_color=(1.0, 0., 0.), B_color=(0., 1.0, 0.), YvalsA=[0.1, 0.2, 0, 1], YvalsB=[0.05, 0.15, 0, 1],	apply_fade=0, fade_sec=0.5, 
	samplingfreq=120.0, shiftval=0.05, color_shift=[-0.3,0,0], plotrange=[-1.1,1.1], forshow0_forsave1=0, createvideoYN=0, 
	create_highangle_videoYN=0, videofortrials=(0,-1), epsilon=0.0123, A_code=1, B_code=4, trial_code=8, framerate=120.0, 
	outlier_th = 20, windowwidth_cm = 36.5, windowwidth_pix = 1280, fixationdistance = 60):

	# Scale Yvals to plotrange
	YvalsA = np.array(YvalsA) * plotrange[1]
	YvalsB = np.array(YvalsB) * plotrange[1]

	# From the list of datafiles, read data and use bokeh to generate javascript plots, then create html with bokeh's plots.
	for datafile in datafileslist:											# for each data file
		print 'datafile used: {0}\n'.format(os.path.split(datafile)[1])		# print the name of the current data file 

		ds = DataStruct(datafile, 											# create new DataStruct instance
		A_code = A_code, B_code = B_code, trial_code = trial_code,			# codes for percepts and trial
		epsilon = epsilon, plotrange = plotrange)							# other parameters

		mycontainer = [html_container() for k in range(ds.numtrials + 2)] 	# container for html and javascript plot codes
		cit = 0 															# container iterator

		Tmax = ds.trial_ts[-1] + 3000										# get ending time of last trial

	
		# Plot input only ------------------------------------------------------------------------------------------------------
		if not ds.eyetrackerdata:
	
			bokehfig = figure(title = 'Input time stamps')
			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press

			for event in ds.trial_ts:																				# for each event time stamp
			 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))			# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')
			
			bokehfig.xaxis.axis_label='Time (ms)'

			mycontainer[cit].scriptTC, mycontainer[cit].divTC = components(plot, CDN) 								# add javascript cdode generated by bokeh to container
			reset_output()
			cit += 1

			it = 0
			for trial in range(ds.numtrials):
				start = ds.trial_ts[it]										# start of trial value
				end = ds.trial_ts[it+1]										# end of trial value

				trial_ts = [start, end]

				bokehfig = figure(title = 'Trial {0}. X coordinate. Right eye shifted {1}'.format(trial+1,shiftval))
					
				for event in trial_ts:																								# for each event time stamp
				 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))						# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

				plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
				plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
				
				bokehfig.xaxis.axis_label='Time (ms)'

				mycontainer[cit].scriptTC, mycontainer[cit].divTC = components(plot, CDN) 											# add javascript cdode generated by bokeh to container
				reset_output()
				cit += 1
				it += 2

		else: # Plot eyetracker data and button presses ------------------------------------------------------------------------------------------

			ds.rightgazeX += shiftval 											# apply shift
			ds.rightgazeY += shiftval 											# apply shift

			# Plot X and Y gaze data over time stamps of all experiment ---------------------------------------------------------------------------
			# Plot X coordinate for both eyes -----------------------------------------------------------------------------------------------------
			TOOLS="pan,wheel_zoom,box_zoom,reset,hover"
			bokehfig = figure(title = 'X coordinates. Right eye shifted {0}'.format(shiftval),tools=TOOLS)

			source = ColumnDataSource(data=dict(x=ds.timestamps,y=ds.leftgazeX))

			bokehfig.scatter(ds.timestamps,ds.leftgazeX,  marker = 'x', color=rgb2hex(A_color), legend='left eye', source = source)
			bokehfig.scatter(ds.timestamps,ds.rightgazeX, marker = 'o', color=rgb2hex(B_color), legend='right eye')
			hover = bokehfig.select(dict(type=HoverTool))
			hover.tooltips = [
			# add to this
			("ts", "$x"),
			("val", "$y"),	
			]

			for event in ds.trial_ts:																			# for each event time stamp
			 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')	# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')	# plot TC. left press
			
			bokehfig.xaxis.axis_label='Time (ms)'
			bokehfig.yaxis.axis_label='X gaze'

			# samples = 5
			# LGavg = movingaverage(ds.leftgazeX[idx_start:idx_end], samples)
			# TSavg = movingaverage(ds.timestamps[idx_start:idx_end], samples)
			# # print LGavg

			# bokehfig.line(TSavg, LGavg, size=12, color="red", alpha=0.5)

			mycontainer[cit].scriptX, mycontainer[cit].divX = components(plot, CDN) # add javascript cdode generated by bokeh to container
			reset_output()

			## plot Y coordinates for both eyes -----------------------------------------------------------------------------------------------------

			bokehfig = figure(title = 'Y coordinates. Right eye shifted {0}'.format(shiftval))
			
			bokehfig.scatter(ds.timestamps,ds.leftgazeY,  marker = 'x', color=rgb2hex(A_color), legend='left eye')
			bokehfig.scatter(ds.timestamps,ds.rightgazeY, marker = 'o', color=rgb2hex(B_color), legend='right eye')

			for event in ds.trial_ts:																			# for each event time stamp
			 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')	# plot TC. left press
			
			bokehfig.xaxis.axis_label='Time (ms)'
			bokehfig.yaxis.axis_label='Y gaze'

			mycontainer[cit].scriptY, mycontainer[cit].divY = components(plot, CDN) # add javascript cdode generated by bokeh to container
			reset_output()

			# Plot X and Y gaze velocity over time stamps of all experiment -----------------------------------------------------------------------
			## plot X velocity for both eyes ------------------------------------------------------------------------------------------------------

			v_leftx  = ds.leftgazeXvelocity[~is_outlier(ds.leftgazeXvelocity, outlier_th)]		 	 			# filter outliers		
			v_rightx = ds.rightgazeXvelocity[~is_outlier(ds.rightgazeXvelocity, outlier_th)] + shiftval;		# filter outliers
			
			bokehfig = figure(title = 'X gaze velocity. Right eye shifted {0}'.format(shiftval))

			bokehfig.line(ds.timestamps,v_leftx, color=rgb2hex(A_color), legend='left eye')
			bokehfig.scatter(ds.timestamps,v_leftx, marker='x', color=rgb2hex(A_color))
			bokehfig.line(ds.timestamps,v_rightx, color=rgb2hex(B_color), legend='right eye')
			bokehfig.scatter(ds.timestamps,v_rightx, marker='x', color=rgb2hex(B_color))


			for event in ds.trial_ts:																			# for each event time stamp
			 	bokehfig.line((event, event), (-YvalsA[1]/2,YvalsA[1]), 'k-', color = rgb2hex((0,0,0)))			# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')	# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')	# plot TC. left press
			
			bokehfig.xaxis.axis_label='Time (ms)'
			bokehfig.yaxis.axis_label='X gaze velocity'

			mycontainer[cit].scriptXvel, mycontainer[cit].divXvel = components(plot, CDN) # add javascript cdode generated by bokeh to container
			reset_output()


			## plot Y velocity for both eyes ----------------------------------------------------------------------------------------------------------

			v_lefty  = ds.leftgazeYvelocity[~is_outlier(ds.leftgazeYvelocity, outlier_th)]		 	 			# filter outliers		
			v_righty = ds.rightgazeYvelocity[~is_outlier(ds.rightgazeYvelocity, outlier_th)] + shiftval;		# filter outliers

			bokehfig = figure(title = 'Y Gaze velocity. Right eye shifted {0}'.format(shiftval))

			bokehfig.line(ds.timestamps,v_lefty, color=rgb2hex(A_color), legend='left eye')
			bokehfig.scatter(ds.timestamps,v_lefty, marker = 'x', color=rgb2hex(A_color))
			bokehfig.line(ds.timestamps,v_righty, color=rgb2hex(B_color), legend='right eye')
			bokehfig.scatter(ds.timestamps,v_righty, marker = 'x', color=rgb2hex(B_color))

			for event in ds.trial_ts:																			# for each event time stamp
			 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')	# plot TC. left press
			
			bokehfig.xaxis.axis_label='Time (ms)'
			bokehfig.yaxis.axis_label='Y Gaze velocity'

			mycontainer[cit].scriptYvel, mycontainer[cit].divYvel = components(plot, CDN) # add javascript cdode generated by bokeh to container
			reset_output()

			## plot XY gaze ------------------------------------------------------------------------------------------------------------------------
			bokehfig = figure(title = 'XY LEFT gaze', x_range = [-1,1], y_range = [-1,1])

			bokehfig.scatter(ds.leftgazeX,ds.leftgazeY,marker = 'x', color=rgb2hex((1,0,0)), legend='left eye')
			bokehfig.xaxis.axis_label='X'
			bokehfig.yaxis.axis_label='Y'

			mycontainer[cit].scriptXY, mycontainer[cit].divXY = components(bokehfig, CDN) # add javascript cdode generated by bokeh to container
			reset_output()


			# Plot vergence -----------------------------------------------------------------------------------------------------------------------

			bokehfig = figure(title = 'Vergence')
			
			bokehfig.line(ds.timestamps,ds.vergence, color=rgb2hex(A_color), legend='vergence')

			for event in ds.trial_ts:																			# for each event time stamp
			 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')	# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')	# plot TC. left press
			
			bokehfig.xaxis.axis_label='Time (ms)'
			bokehfig.yaxis.axis_label='Vergence'

			mycontainer[cit].verg_script, mycontainer[cit].verg_div = components(plot, CDN) # add javascript cdode generated by bokeh to container
			reset_output()


			# Plot fixation distance -----------------------------------------------------------------------------------------------------------

			bokehfig = figure(title = 'Fixation distance')
			
			bokehfig.line(ds.timestamps,ds.fixationdist, color=rgb2hex(A_color), legend='fixation distance')

			for event in ds.trial_ts:																			# for each event time stamp
			 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

			plot = bokeh_plotTC(bokehfig, ds.A_ts, Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')	# plot TC. left press
			plot = bokeh_plotTC(bokehfig, ds.B_ts, Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')	# plot TC. left press
			
			bokehfig.xaxis.axis_label='Time (ms)'
			bokehfig.yaxis.axis_label='Fixation distance'

			mycontainer[cit].fixd_script, mycontainer[cit].fixd_div = components(plot, CDN) # add javascript cdode generated by bokeh to container
			reset_output()


			cit += 1

			# For each trial, plot gaze and input ----------------------------------------------------------------------------------------------------
			if ds.numtrials > 1:
				it = 0																# iterator
				for trial in range(ds.numtrials):
					## Compute indexes. TrialEvent times do not have to match eyetracker times

					if apply_fade: fade_samp = samplingfreq * fade_sec				# obtain samples for data fade
					
					start = ds.trial_ts[it]											# start of trial value
					end = ds.trial_ts[it+1]											# end of trial value

					val, idx_start = find_nearest_above(ds.timestamps, start)		# find nearest above eyetracker time stamp

					if apply_fade and not trial == 0: 								# for the first trial, there's no fade in.
						idx_start = idx_start - fade_samp 							# apply fade in

					if not trial == (ds.numtrials-1):								# if not the last trial,
						val, idx_end = find_nearest_above(ds.timestamps, end)		# find nearest above eyetracker time stamp

						if apply_fade: idx_end = idx_end + fade_samp				# apply fade out
					else:
						idx_end = end

					trial_ts = [start, end] 										# 

					ts  = ds.timestamps[idx_start:idx_end] 							# timestamps   of this trial
					lgX = ds.leftgazeX[idx_start:idx_end] 							# left  X gaze of this trial
					lgY = ds.leftgazeY[idx_start:idx_end] 							# left  Y gaze of this trial
					rgX = ds.rightgazeX[idx_start:idx_end]							# right X gaze of this trial
					rgY = ds.rightgazeY[idx_start:idx_end] 							# right Y gaze of this trial
					vrg = ds.vergence[idx_start:idx_end] 							# vergence     of this trial
					fxd = ds.fixationdist[idx_start:idx_end]						# vergence     of this trial

					vlx = v_leftx[idx_start:idx_end]  								# velocity of this trial
					vrx = v_rightx[idx_start:idx_end]
					vly = v_lefty[idx_start:idx_end]
					vry = v_righty[idx_start:idx_end]


					## plot X coordinate for both eyes -----------------------------------------------------------------------------------------------------

					bokehfig = figure(title = 'Trial {0}. X coordinate. Right eye shifted {1}'.format(trial+1,shiftval))
					
					bokehfig.scatter(ts,lgX,  marker = 'x', color=rgb2hex(A_color), legend='left eye')
					bokehfig.scatter(ts,rgX,  marker = 'o', color=rgb2hex(B_color), legend='right eye')

					for event in trial_ts:																				# for each event time stamp
					 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

					plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
					plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
					
					bokehfig.xaxis.axis_label='Time (ms)'
					bokehfig.yaxis.axis_label='X gaze'


					mycontainer[cit].scriptX, mycontainer[cit].divX = components(plot, CDN) # add javascript cdode generated by bokeh to container
					reset_output()
					
					## plot Y coordinate for both eyes -----------------------------------------------------------------------------------------------------
					
					bokehfig = figure(title = 'Trial {0}. Y coordinate. Right eye shifted {1}'.format(trial+1,shiftval))
					
					bokehfig.scatter(ts, lgY,  marker = 'x', color=rgb2hex(A_color), legend='left eye')
					bokehfig.scatter(ts, rgY,  marker = 'o', color=rgb2hex(B_color), legend='right eye')

					for event in trial_ts:																				# for each event time stamp
					 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

					plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
					plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
					
					bokehfig.xaxis.axis_label='Time (ms)'
					bokehfig.yaxis.axis_label='Y gaze'

					mycontainer[cit].scriptY, mycontainer[cit].divY = components(plot, CDN) # add javascript cdode generated by bokeh to container
					reset_output()


					# Plot X and Y gaze velocity ----------------------------------------------------------------------------------------------------------
					## plot X velocity for both eyes ------------------------------------------------------------------------------------------------------
					
					bokehfig = figure(title = 'Trial {0}. X gaze velocity. Right eye shifted {1}'.format(trial+1,shiftval))

					bokehfig.line(ts,vlx, color=rgb2hex(A_color), legend='left eye')
					bokehfig.scatter(ts,vlx, marker='x', color=rgb2hex(A_color))
					bokehfig.line(ts,vrx, color=rgb2hex(B_color), legend='right eye')
					bokehfig.scatter(ts,vrx, marker='o', color=rgb2hex(B_color))

					for event in trial_ts:																			# for each event time stamp
					 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

					plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
					plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
					
					bokehfig.xaxis.axis_label='Time (ms)'
					bokehfig.yaxis.axis_label='Gaze velocity'

					mycontainer[cit].scriptXvel, mycontainer[cit].divXvel = components(plot, CDN) # add javascript cdode generated by bokeh to container
					reset_output()

					## plot Y velocity for both eyes ----------------------------------------------------------------------------------------------------------

					bokehfig = figure(title = 'Trial {0}. Y gaze velocity. Right eye shifted {1}'.format(trial+1,shiftval))
					
					bokehfig.line(ts,vly,  color=rgb2hex(A_color), legend='left eye')
					bokehfig.scatter(ts,vly, marker = 'x', color=rgb2hex(A_color))
					bokehfig.line(ts,vry, color=rgb2hex(B_color), legend='right eye')
					bokehfig.scatter(ts,vry, marker = 'o', color=rgb2hex(B_color))

					for event in trial_ts:																			# for each event time stamp
					 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

					plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
					plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
					
					bokehfig.xaxis.axis_label='Time (ms)'
					bokehfig.yaxis.axis_label='Y gaze'

					mycontainer[cit].scriptYvel, mycontainer[cit].divYvel = components(plot, CDN) # add javascript cdode generated by bokeh to container
					reset_output()

					## plot XY gaze ------------------------------------------------------------------------------------------------------------------------
					bokehfig = figure(title = 'Trial {0}. XY LEFT gaze'.format(trial+1), x_range = [-1,1], y_range = [-1,1])

					bokehfig.scatter(lgX,lgY,marker = 'x', color=rgb2hex((1,0,0)), legend='left eye')
					bokehfig.xaxis.axis_label='X'
					bokehfig.yaxis.axis_label='Y'

					mycontainer[cit].scriptXY, mycontainer[cit].divXY = components(bokehfig, CDN) # add javascript cdode generated by bokeh to container
					reset_output()


					# Plot vergence -----------------------------------------------------------------------------------------------------------------------

					bokehfig = figure(title = 'Trial {0}. Vergence'.format(trial+1))
					
					bokehfig.line(ts,vrg, color=rgb2hex(A_color), legend='vergence')

					for event in trial_ts:																				# for each event time stamp
					 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

					plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
					plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
					
					bokehfig.xaxis.axis_label='Time (ms)'
					bokehfig.yaxis.axis_label='Vergence'

					mycontainer[cit].verg_script, mycontainer[cit].verg_div = components(plot, CDN) # add javascript cdode generated by bokeh to container
					reset_output()


					# Plot fixation distance -----------------------------------------------------------------------------------------------------------

					bokehfig = figure(title = 'Trial {0}. Fixation distance'.format(trial+1))
					
					bokehfig.line(ts,fxd, color=rgb2hex(A_color), legend='fixation distance')

					for event in trial_ts:																			# for each event time stamp
					 	bokehfig.line((event, event), (plotrange[0],plotrange[1]), 'k-', color = rgb2hex((0,0,0)))		# plot a vertical line: plt.plot((x1,x2),(y1,y2),'k-')

					plot = bokeh_plotTC(bokehfig, ds.A_trial[trial], Tmax, YvalsA, A_color, change_axis=1, label = 'Left input')		# plot TC. left press
					plot = bokeh_plotTC(bokehfig, ds.B_trial[trial], Tmax, YvalsB, B_color, change_axis=1, label = 'Right input')		# plot TC. left press
					
					bokehfig.xaxis.axis_label='Time (ms)'
					bokehfig.yaxis.axis_label='Fixation distance'

					mycontainer[cit].fixd_script, mycontainer[cit].fixd_div = components(plot, CDN) # add javascript cdode generated by bokeh to container
					reset_output()
					

					# Optional: Create X,Y video for current trial ------------------------------------------------------------------------
					if createvideoYN and trial in videofortrials: 
						print 'create video for trial {0}'.format(trial)
						videoname = '{0}_{1}_Trial_{2}_XYplotmoviepy.mp4'.format(ds.expname, ds.subjectname, trial+1)

						# filter data per 5
						samples = 100
						ts  = movingaverage(ds.timestamps[idx_start:idx_end], samples)
						lgx = movingaverage(ds.leftgazeX[idx_start:idx_end],samples)
						lgy = movingaverage(ds.leftgazeY[idx_start:idx_end],samples)

						t = time.time()
						createvideowithmoviepy(ts, lgx, lgy, videoname = videoname)
						elapsed = time.time() - t
						print 'creating a video with matplotlib took: {0} seconds'.format(elapsed)

						mycontainer[cit].XYvideolink = videoname

					# Optional: Create High-angle video for current trial ------------------------------------------------------------------------
					if create_highangle_videoYN and trial in videofortrials:
						videoname = '{0}_{1}_Trial_{2}_HAplot.mp4'.format(ds.expname, ds.subjectname, trial+1)
						print 'creating high angle video'
						create_highangle_video(ds.timestamps[idx_start:idx_end], ds.leftgazeX[idx_start:idx_end], ds.rightgazeX[idx_start:idx_end], videoname = 'highanglevideo.mp4')

						mycontainer[cit].HAvideolink = videoname
						
					cit += 1
					it += 2 																					# increase iterator


		# Create Interactive html ------------------------------------------------------------------------------------------------------------
		fWebName = '{0}.html'.format(os.path.splitext(os.path.split(datafile)[1])[0])
		## copy header
		with open(fWeb_HEADER,'r') as head:
			header = head.read()

		with open(fWebName, 'w' ) as fWebID:															#
			fWebID.seek(0)
			create_interactive_html(datastruct = ds, cont = mycontainer, fWebID=fWebID, fWeb_HEADER = header)

		print 'html saved as {0}'.format(fWebName)


		# Create html --------------------------------------------------------------------------------------------------------------------------
		if forshow0_forsave1:

			## check if html file name already exists
			if os.path.exists(fWebName):																	# if html file exists
				result = askquestion("Message", "HTML name already exists. Do you want to overwrite it?")	# overwrite it?
				if result == 'no':																			# if no overwrite it
					fWeb_NAME = askstring('HTML name exists','write new html file name')					# write new name

			with open(fWebName, 'w' ) as fWebID:															#
				add_figs_in_html(datastruct = ds, fWebID=fWebID, DIR_IN = DIR_IN, DIR_OUT = DIR_OUT, fWeb_HEADER = header)		#
				# fWebID.write('\n</table>') 																	# close table (it is opened in add_figs_in_html)

	pass

class html_container():
	def __init__(self):
		self.scriptX 	 = []		# javascript code for X gaze bokeh's plot
		self.divX 	 	 = []		# html div that references self.scriptX
		
		self.scriptY 	 = []		# javascript code for Y gaze bokeh's plot
		self.divY 	 	 = []		# html div that references self.scriptX

		self.scriptXvel  = []		# javascript code for X gaze bokeh's plot
		self.divXvel 	 = []		# html div that references self.scriptX
		
		self.scriptYvel = []		# javascript code for Y gaze bokeh's plot
		self.divYvel 	= []		# html div that references self.scriptX

		self.scriptXY 	= []		# javascript code for Y gaze bokeh's plot
		self.divXY	 	= []		# html div that references self.scriptX

		self.hist_script = []		# javascript code for histogram bokeh's plot
		self.hist_div	 = []		# html div that references self.hist_script

		self.verg_script = []		# javascript code for vergence bokeh's plot
		self.verg_div	 = []		# html div that references self.verg_script

		self.fixd_script = []		# javascript code for fixation distance bokeh's plot
		self.fixd_div	 = []		# html div that references self.fixd_script

		self.XYvideolink = []		# relative path to the x,y gaze video
		self.HAvideolink = []		# relative path to the high angle video

		self.scriptTC 	= []		# javascript code for TC bokeh's plot
		self.divTC	 	= []		# html div that references self.divTC


	def function(self):
		pass

def bokeh_plotTC(figure, time_stamps, time_max, Y_vals, color, change_axis = 0, label = ''):
	"""
	Plot time-course of perceptual alternation of ONE percept (left or right)
	Arguments:
	- figure: handle to the figure (or subplot) where TC should be drawn
	- time_stamps: a Nx2 matrx. Each row is pair [time_press, time_release] of
		a mouse/key event (percept start and end)
	- time_max: xmax value (for axis ([xmin, xmax, ymin, ymax]) call)
	- Y_vals: 1x4 vector with Yon, Yoff and ymin, ymax values
	- color: a 1x3 vector with RGB values of the plot line color
	- change_axis: if 1, changes the x and y axis using time_max and Y_vals
	- label: name to appear in legend
	"""
	ymin = Y_vals[2]
	ymax = Y_vals[3]

	# tiny = time_max/1000 # tiny dx to draw 'vertical' lines in TC
	tiny = 0

	# if change_axis: figure.axis([0, time_max, ymin, ymax])
	# if change_axis: figure.x_range = [0, time_max]

	color = rgb2hex(color)

	for i in range(len(time_stamps)):
		figure.line(time_stamps[i], [Y_vals[0], Y_vals[1]], color = color, legend = label)
		figure.line([time_stamps[i][0]-tiny, time_stamps[i][0]], [ymin, Y_vals[0]], color = color, line_dash = 'dotted')
		figure.line([time_stamps[i][1]-tiny, time_stamps[i][1]], [ymin, Y_vals[1]], color = color, line_dash = 'dotted')
	pass

	return figure

def bokeh_histogram(figure, percept_timestamps, binw, fil_color = "#036564", line_color="#033649"):
	# 	Create a histogram:
	# - figure: 			bokeh figure
	# - percept_timestamps: list of lists containing percept time values as [[on_0 off_0] [on_1 off_1] ... ]
	# - binw: 				number of bins for the histogram
	percept_duration = [x[1] - x[0] for x in percept_timestamps]													# compute duration of each percept
	hist, edges = np.histogram(percept_duration, density=True, bins=binw) 											# create histogram
	figure.quad(top=histA, bottom=0, left=edges[:-1], right=edges[1:], fill_color=fil_color, line_color=line_color) # plot histogram

	return figure	

def create_interactive_html(datastruct = None, cont = None, fWebID='', fWeb_HEADER = ''):
	videowidth, videoheight = 800,600

	fWebID.write(fWeb_HEADER)										# add header

	# Write button presses only -------------------------------------------------------------------------------
	if not datastruct.eyetrackerdata: 
		for i in range(len(cont)):										# for each element in container
			script = cont[i].scriptTC									# get script for X coordinates
			fWebID.write('\n<!-- Script for TC -->') 					# write comment in html
			fWebID.write('\n\t\t{0}'.format(str(script)))				# write script
	
		fWebID.write('\n\t</head>')										# write end of head tag (identation)	
		fWebID.write('\n\t</body>')										# open body	tag
		
		fWebID.write('\n<b>Filename:</b> {0}</p>'.format( 				# write data file name
			datastruct.filename))

		# write plots
		fWebID.write('\n\t\t<table>') 									# create new table
		
		fWebID.write('\n<!-- Div for TC plot -->')		 				# write comment in html
		fWebID.write('\n\t\t\t<tr>') 									# create new row (plots in different colums)
		for i in range(len(cont)):										# for each element in container
			divTC = cont[i].divTC										# get div for X coordinates
			
			fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
			fWebID.write('\n\t\t\t\t\t')								# write identation
			fWebID.write(str(divTC))									# write div for i script
			fWebID.write('\n\t\t\t\t</td>')								# close cell tag
		
		fWebID.write('\n\t\t\t</tr>') 									# close row tag

		fWebID.write('\n\t</body>')										# close body	
		fWebID.write('\n</html>')										# close html

	# Write eyetracker and button presses data ---------------------------------------------------------------------
	else:

		for i in range(len(cont)):										# for each element in container
			script = cont[i].scriptX									# get script for X coordinates
			fWebID.write('\n<!-- Script for X coordinates -->') 		# write comment in html
			fWebID.write('\n\t\t{0}'.format(str(script)))				# write script

			script = cont[i].scriptXvel									# get script for X velocity
			fWebID.write('\n<!-- Script for X velocity -->')	 		# write comment in html
			fWebID.write('\n\t\t{0}'.format(str(script)))				# write script

			script = cont[i].scriptY									# get script for Y coordinates
			fWebID.write('\n<!-- Script for Y coordinates -->') 		# write comment in html
			fWebID.write('\n\t\t{0}'.format(str(script)))				# write script

			script = cont[i].scriptYvel									# get script for Y velocity
			fWebID.write('\n<!-- Script for Y velocity -->')	 		# write comment in html
			fWebID.write('\n\t\t{0}'.format(str(script)))				# write script

			script = cont[i].scriptXY									# get script for XY gaze
			fWebID.write('\n<!-- Script for XY plot -->')		 		# write comment in html
			fWebID.write('\n\t\t{0}'.format(str(script)))				# write script

			# script = cont[i].verg_script								# get script for vergence
			# fWebID.write('\n<!-- Script for vergence plot -->') 		# write comment in html
			# fWebID.write('\n\t\t{0}'.format(str(script)))				# write script

			# script = cont[i].fixd_script								# get script for fixation distance
			# fWebID.write('\n<!-- Script for fixation distance plot -->')# write comment in html
			# fWebID.write('\n\t\t{0}'.format(str(script)))				# write script


		fWebID.write('\n\t</head>')										# write end of head tag (identation)	
		fWebID.write('\n\t</body>')										# open body	tag
		
		fWebID.write('\n<b>Filename:</b> {0}</p>'.format(datastruct.filename))

		# write plots
		fWebID.write('\n\t\t<table>') 									# create new table
		
		
		# Write X gaze data in a row -------------------------------------------------------------------------------
		fWebID.write('\n<!-- Div for X gaze plot -->')		 			# write comment in html
		fWebID.write('\n\t\t\t<tr>') 									# create new row (plots in different colums)
		for i in range(len(cont)):										# for each element in container
			divX = cont[i].divX											# get div for X coordinates
			
			fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
			fWebID.write('\n\t\t\t\t\t')								# write identation
			fWebID.write(str(divX))										# write div for i script
			fWebID.write('\n\t\t\t\t</td>')								# close cell tag
		
		fWebID.write('\n\t\t\t</tr>') 									# close row tag

		# Write X velocity in a row ------------------------------------------------------------------------------------
		fWebID.write('\n<!-- Div for X velocity plot -->')	 			# write comment in html
		fWebID.write('\n\t\t\t<tr>') 									# create new row
		for i in range(len(cont)):										# for each element in container
			divXvel = cont[i].divXvel									# get div for X coordinates
			
			fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
			fWebID.write('\n\t\t\t\t\t')								# write identation
			fWebID.write(str(divXvel))									# write div for i script
			fWebID.write('\n\t\t\t\t</td>')								# close cell tag

		# Write Y gaze data in a row -----------------------------------------------------------------------------------
		fWebID.write('\n<!-- Div for Y gaze plot -->')		 			# write comment in html
		fWebID.write('\n\t\t\t<tr>') 									# create new row tag
		for i in range(len(cont)):										# for each element in container
			divY = cont[i].divY											# get div for Y coordinates

			fWebID.write('\n\t\t\t\t<td>')								# create new cell		
			fWebID.write('\n\t\t\t\t\t')
			fWebID.write(str(divY))										# write div for i script
			fWebID.write('\n\t\t\t\t</td>')								# close new cell
		
		fWebID.write('\n\t\t\t</tr>') 									# close row tag

		# Write Y velocity in a row ------------------------------------------------------------------------------------
		fWebID.write('\n<!-- Div for Y velocity plot -->')	 			# write comment in html
		fWebID.write('\n\t\t\t<tr>') 									# create new row
		for i in range(len(cont)):										# for each element in container
			divYvel = cont[i].divYvel									# get div for X coordinates
			
			fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
			fWebID.write('\n\t\t\t\t\t')								# write identation
			fWebID.write(str(divYvel))									# write div for i script
			fWebID.write('\n\t\t\t\t</td>')								# close cell tag


		# # Write XY gaze data in a row -------------------------------------------------------------------------------
		fWebID.write('\n<!-- Div for XY gaze plot -->')	 				# write comment in html
		fWebID.write('\n\t\t\t<tr>') 									# create new row (plots in different colums)
		for i in range(len(cont)):										# for each element in container
			divXY = cont[i].divXY										# get div for XY gaze
			
			fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
			fWebID.write('\n\t\t\t\t\t')								# write identation
			fWebID.write(str(divXY))									# write div for i script
			fWebID.write('\n\t\t\t\t</td>')								# close cell tag

		# # Write vergence data in a row ------------------------------------------------------------------------------
		# fWebID.write('\n<!-- Div for vergence plot -->')				# write comment in html
		# fWebID.write('\n\t\t\t<tr>') 									# create new row (plots in different colums)
		# for i in range(len(cont)):										# for each element in container
		# 	divXY = cont[i].verg_div									# get div for vergence
			
		# 	fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
		# 	fWebID.write('\n\t\t\t\t\t')								# write identation
		# 	fWebID.write(str(divXY))									# write div for i script
		# 	fWebID.write('\n\t\t\t\t</td>')								# close cell tag

		# # Write fixation distance in a row --------------------------------------------------------------------------
		# fWebID.write('\n<!-- Div for fixation dist plot -->')			# write comment in html
		# fWebID.write('\n\t\t\t<tr>') 									# create new row (plots in different colums)
		# for i in range(len(cont)):										# for each element in container
		# 	divXY = cont[i].fixd_div									# get div for fixation distance
			
		# 	fWebID.write('\n\t\t\t\t<td>')								# create new cell (colum)
		# 	fWebID.write('\n\t\t\t\t\t')								# write identation
		# 	fWebID.write(str(divXY))									# write div for i script
		# 	fWebID.write('\n\t\t\t\t</td>')								# close cell tag
		
		# # fWebID.write('\n\t\t\t</tr>') 									# close row tag

		# Write video XY links in a row ------------------------------------------------------------------------------
		fWebID.write('\n\t\t\t<tr>') 									# create new row tag
		for i in range(len(cont)):										# for each element in container
			videolink = cont[i].XYvideolink								# get div for Y coordinates

			fWebID.write('\n\t\t\t\t<td>')								# create  cell		
			fWebID.write('\n\t\t\t\t\t')
			
			if videolink: 
				fWebID.write('<video width="{0}" height="{1}" controls>'.format(videowidth, videoheight))
				fWebID.write('\n\t\t\t\t\t\t')
				fWebID.write('<source src="{0}" type="video/mp4">'.format(str(videolink)))					# write div for i script
				fWebID.write('Your browser does not support HTML5 video.')
				fWebID.write('\n\t\t\t\t\t</video>')
				
			fWebID.write('\n\t\t\t\t</td>')								# close cell
		
		fWebID.write('\n\t\t\t</tr>') 									# close row tag



		# Write video HA links in a row ----------------------------------------------------------------------------------
		fWebID.write('\n\t\t\t<tr>') 									# create new row tag
		for i in range(len(cont)):										# for each element in container
			videolink = cont[i].HAvideolink								# get div for Y coordinates

			fWebID.write('\n\t\t\t\t<td>')								# create  cell		
			fWebID.write('\n\t\t\t\t\t')
			
			if videolink: 
				fWebID.write('<video width="{0}" height="{1}" controls>'.format(videowidth, videoheight))
				fWebID.write('\n\t\t\t\t\t\t')
				fWebID.write('<source src="{0}" type="video/mp4">'.format(str(videolink)))			
				fWebID.write('Your browser does not support HTML5 video.')
				fWebID.write('\n\t\t\t\t\t</video>')
				
			fWebID.write('\n\t\t\t\t</td>')								# close cell
		
		fWebID.write('\n\t\t\t</tr>') 									# close row tag



		############
		# Put more things here
		############


		fWebID.write('\n\t</body>')			# close body	
		fWebID.write('\n</html>')			# close html

	pass

def plot_XYeye(figure,x,y,label='', color = (1.0,0.0,0.0), anotation = 0, text = None):

	figure.scatter(x,y,marker = 'x', color = color, label = label)
	
	# figure.set_ylim([0,1])
	# figure.set_xlim([0,1])
	# if anotation: plt.annotate('({0},{1})'.format(x,y), xy = (x,y), xytext = (x, y-0.1))
	
	if anotation and text is not None:
		text.set_text('({0},{1})'.format( '%.2f' % (x),'%.2f' % (y)))
		text.set_position((x-0.05,y-0.05))

	return figure

def createvideo(timestamps, LgazeX, LgazeY, RgazeX = '', RgazeY = '', videoname = '', xlabel = '', plottitle = '', show_pos = 1):

	import matplotlib
	matplotlib.use("Agg", warn = False)
	import matplotlib.animation as manimation

	FFMpegWriter = manimation.writers['ffmpeg']
	metadata = dict(title='Movie Test', artist='Matplotlib', comment='Movie support!')
	writer = FFMpegWriter(fps=24, extra_args=['-vcodec', 'h264', '-pix_fmt', 'yuv420p'], metadata=metadata)

	fig = plt.figure()
	left_eye, = plt.plot([], [], 'k-o')
	# right_eye, = plt.plot([], [], 'k-o')

	plt.xlim(0, 1)
	plt.ylim(0, 1)

	plt.xlabel(xlabel)
	plt.title(plottitle)

	lpostext = fig.text(0, 0, "")
	# rpostext = fig.text(0, 0, "")

	frameinfo = fig.text(0, 0, "")

	with writer.saving(fig, videoname, 100):
	    for i in range(len(timestamps)):
			lx = LgazeX[i]
			ly = LgazeY[i]
			# rx = RgazeX[i]
			# ry = RgazeY[i]
			ts = timestamps[i]

			left_eye.set_data(lx, ly)
			# right_eye.set_data(rx, ry)
			
			if show_pos:
				lpostext.set_text('({0},{1})'.format( '%.2f' % (lx),'%.2f' % (ly)))
				lpostext.set_position((lx-0.05,ly-0.05))

				# rpostext.set_text('({0},{1})'.format( '%.2f' % (rx),'%.2f' % (ry)))
				# rpostext.set_position((rx-0.05,ry-0.05))

			frameinfo.set_text("timestamp: {0} frame: {1}".format(ts, i))

			writer.grab_frame()

def create_highangle_video(timestamps, Lgaze_array, Rgaze_array, videoname = ''):
	import matplotlib
	matplotlib.use("Agg", warn = False)	# warn = False will supress warnings
	import matplotlib.animation as manimation
	
	##########################
	# Initialize video writer 
	##########################

	FFMpegWriter = manimation.writers['ffmpeg']
	metadata = dict(title='highanglegazevideo', artist='Matplotlib', comment='Movie support!')
	writer = FFMpegWriter(fps=15, metadata=metadata)

	######################
	# Constants definition
	######################
	lpos = [-0.5, -1]																		# position of left eye
	rpos = [0.5, -1]																		# position of right eye

	lcolor = (1.0, 0., 0.)																	# left eye/gaze/line color
	rcolor = (0., 1.0, 0.)																	# right eye/gaze/line color

	eyesize = 20																			# size of eyes
	gazesize = 5																			# size of gaze

	xmin, xmax, ymin, ymax = -1, 1, -1, 1													# plot limits

	y_scrn = 0																				# y position of the dashed line in the middle (screen)


	fig = plt.figure()																		# initialize figure

	###############################################
	# Initialize Drawings (only the ones that move)
	################################################

	leg, = plt.plot([lpos[0], Lgaze_array[0]],[lpos[1], y_scrn], '--', color = lcolor)						# line from left eye to left gaze
	reg, = plt.plot([rpos[0], Rgaze_array[0]],[rpos[1], y_scrn], '--', color = rcolor)						# line from right eye to right gaze

	lgt, = plt.plot([Lgaze_array[0], 2*Lgaze_array[0] - lpos[0]],[y_scrn, ymax], '--', color = lcolor)		# line from left gaze to top of plot
	rgt, = plt.plot([Rgaze_array[0], 2*Rgaze_array[0] - rpos[0]],[y_scrn, ymax], '--', color = rcolor)		# line from right gaze to top of plot

	lg, = plt.plot(Lgaze_array[0],y_scrn, 'o', color = lcolor, markersize = gazesize)						# draw left gaze
	rg, = plt.plot(Rgaze_array[0],y_scrn, 'o', color = rcolor, markersize = gazesize)						# draw right gaze

	frameinfo = fig.text(0.1, 0.02, "")																			# frame information
	
	######################
	# Draw each frame
	######################
	with writer.saving(fig, videoname, 100):												# open video
		for i in range(len(timestamps)):													# create each frame
	    	
			lgaze = Lgaze_array[i]															# get left gaze for frame i
			rgaze = Rgaze_array[i]															# get right gaze for frame i

			ts = timestamps[i]																# get timestamp for i frame

			######################
			# Drawings
			######################
			plt.plot(lpos[0],lpos[1], 'o', color = lcolor, markersize = eyesize)			# draw left eye
			plt.plot(rpos[0],rpos[1], 'o', color = rcolor, markersize = eyesize)			# draw right eye

			plt.plot([-1, 1],[y_scrn, y_scrn],'k:')											# draw dashed line in the middle (screen)

			leg.set_data([lpos[0], lgaze],[lpos[1], y_scrn])								# update position of line from left eye to left gaze
			reg.set_data([rpos[0], rgaze],[rpos[1], y_scrn])								# update position of line from right eye to right gaze

			lgt.set_data([lgaze, 2*lgaze - lpos[0]],[y_scrn, ymax])							# update position of line from left gaze to top of plot
			rgt.set_data([rgaze, 2*rgaze - rpos[0]],[y_scrn, ymax])							# update position of line from right gaze to top of plot

			lg.set_data(lgaze,y_scrn)														# update position of left gaze
			rg.set_data(rgaze,y_scrn)														# update position of right gaze


			frameinfo.set_text("timestamp: {0} frame: {1}".format(ts, i))
			plt.axis([xmin, xmax, ymin, ymax]) 												# set axis limits: [xmin, xmax, ymin, ymax]

			writer.grab_frame()																# send frame to movie writer

	pass

if __name__ == '__main__':

	if len(sys.argv) < 2:
		print 'Choose which data files to analyze'
	else:
		pass
	
	## Create GUI to open files
	Tk().withdraw() 																	# we don't want a full GUI, so keep the root window from appearing
	datafileslist = askopenfilenames(title='Chose files to analyze', initialdir = '..') # show an "Open" dialog box and return the path to the selected file

	main(datafileslist = datafileslist, fWeb_HEADER = 'html_template.html')